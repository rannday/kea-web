package main

import (
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"

	"github.com/tdewolff/minify/v2"
	"github.com/tdewolff/minify/v2/css"
	"github.com/tdewolff/minify/v2/js"
)

func fileHash(data []byte) string {
  h := sha256.Sum256(data)
  return hex.EncodeToString(h[:])[:12]
}

func readAndConcat(dir, ext string, orderedFirst []string) ([]byte, error) {
  entries, err := os.ReadDir(dir)
  if err != nil {
    return nil, err
  }

  var b strings.Builder
  seen := map[string]bool{}

  for _, name := range orderedFirst {
    p := filepath.Join(dir, name)
    data, err := os.ReadFile(p)
    if err != nil {
      return nil, fmt.Errorf("read %s: %w", p, err)
    }
    b.Write(data)
    b.WriteString("\n")
    seen[name] = true
  }

  var rest []string
  for _, e := range entries {
    if e.IsDir() {
      continue
    }
    n := e.Name()
    if seen[n] || !strings.HasSuffix(n, ext) {
      continue
    }
    rest = append(rest, n)
  }
  sort.Strings(rest)

  for _, name := range rest {
    p := filepath.Join(dir, name)
    data, err := os.ReadFile(p)
    if err != nil {
      return nil, fmt.Errorf("read %s: %w", p, err)
    }
    b.Write(data)
    b.WriteString("\n")
  }

  return []byte(b.String()), nil
}

func removeOldBundles(dir, ext, keepHash string) error {
  entries, err := os.ReadDir(dir)
  if err != nil {
    return err
  }
  for _, e := range entries {
    if e.IsDir() {
      continue
    }
    n := e.Name()
    if strings.HasPrefix(n, "bundle.") && strings.HasSuffix(n, ext) && !strings.Contains(n, keepHash) {
      _ = os.Remove(filepath.Join(dir, n))
    }
  }
  return nil
}

func writeManifest(handlersDir, cssFile, jsFile string) error {
  // dir is internal/web/handlers/assets_dist
  out := filepath.Join(handlersDir, "manifest.go")
  content := fmt.Sprintf(`// Code generated by cmd/bundle-assets; DO NOT EDIT.

package handlers

const BundledCSS = %q
const BundledJS = %q
`, cssFile, jsFile)

  return os.WriteFile(out, []byte(content), 0644)
}

func main() {
  // Run from repo root (go generate sets CWD to the package dir),
  // so resolve paths relative to the handlers package dir.
  // When invoked via generate.go inside handlers, CWD == internal/web/handlers.
  handlersDir, err := os.Getwd()
  if err != nil {
    panic(err)
  }

  srcCSS := filepath.Join(handlersDir, "assets_src", "css")
  srcJS := filepath.Join(handlersDir, "assets_src", "js")

  distRoot := filepath.Join(handlersDir, "assets_dist")
  distCSS := filepath.Join(distRoot, "css")
  distJS := filepath.Join(distRoot, "js")

  if err := os.MkdirAll(distCSS, 0755); err != nil {
    panic(err)
  }
  if err := os.MkdirAll(distJS, 0755); err != nil {
    panic(err)
  }

  m := minify.New()
  m.AddFunc("text/css", css.Minify)
  m.AddFunc("application/javascript", js.Minify)

  cssOrder := []string{"reset.css", "style.css"}
  jsOrder := []string{"prefetch.js"}

  cssData, err := readAndConcat(srcCSS, ".css", cssOrder)
  if err != nil {
    panic(err)
  }
  jsData, err := readAndConcat(srcJS, ".js", jsOrder)
  if err != nil {
    panic(err)
  }

  cssHash := fileHash(cssData)
  jsHash := fileHash(jsData)

  cssName := "bundle." + cssHash + ".css"
  jsName := "bundle." + jsHash + ".js"

  cssOut := filepath.Join(distCSS, cssName)
  jsOut := filepath.Join(distJS, jsName)

  // Minify + write
  minCSS, err := m.Bytes("text/css", cssData)
  if err != nil {
    panic(err)
  }
  if err := os.WriteFile(cssOut, minCSS, 0644); err != nil {
    panic(err)
  }

  minJS, err := m.Bytes("application/javascript", jsData)
  if err != nil {
    panic(err)
  }
  if err := os.WriteFile(jsOut, minJS, 0644); err != nil {
    panic(err)
  }

  // Cleanup old bundles
  _ = removeOldBundles(distCSS, ".css", cssHash)
  _ = removeOldBundles(distJS, ".js", jsHash)

  if err := writeManifest(
    handlersDir,
    filepath.ToSlash(filepath.Join("css", cssName)),
    filepath.ToSlash(filepath.Join("js", jsName)),
  ); err != nil {
    panic(err)
  }
}
